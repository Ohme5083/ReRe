name: üß™ Test Unit and Integration

on:
  workflow_call:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  DOTNET_VERSION: '9.0.x'
  BUILD_CONFIGURATION: 'Release'
  SOLUTION_FILE: 'ReRe.sln'  # Ajustez selon votre structure
  TEST_PROJECT: 'ReRe.Test/ReRe.Test.csproj'

jobs:
  Test_App:
    name: üß™ Test Application
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ‚öôÔ∏è Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: üîç Detect Solution Structure
        run: |
          echo "üîç Analyzing project structure..."
          echo "üìÅ Current directory contents:"
          ls -la
          echo ""
          echo "üîç Looking for solution files:"
          find . -name "*.sln" -maxdepth 2
          echo ""
          echo "üîç Looking for project files:"
          find . -name "*.csproj" -maxdepth 3
          echo ""
          
          # D√©tecter automatiquement le fichier solution principal
          SOLUTION_COUNT=$(find . -name "*.sln" -maxdepth 2 | wc -l)
          echo "üìä Found $SOLUTION_COUNT solution file(s)"
          
          if [ $SOLUTION_COUNT -eq 1 ]; then
            DETECTED_SOLUTION=$(find . -name "*.sln" -maxdepth 2)
            echo "‚úÖ Solution d√©tect√©e automatiquement: $DETECTED_SOLUTION"
            echo "DETECTED_SOLUTION=$DETECTED_SOLUTION" >> $GITHUB_ENV
          elif [ $SOLUTION_COUNT -gt 1 ]; then
            echo "‚ö†Ô∏è Plusieurs solutions d√©tect√©es:"
            find . -name "*.sln" -maxdepth 2
            # Utiliser la solution sp√©cifi√©e dans les variables d'environnement
            if [ -f "${{ env.SOLUTION_FILE }}" ]; then
              echo "‚úÖ Utilisation de la solution sp√©cifi√©e: ${{ env.SOLUTION_FILE }}"
              echo "DETECTED_SOLUTION=${{ env.SOLUTION_FILE }}" >> $GITHUB_ENV
            else
              echo "‚ùå Solution sp√©cifi√©e introuvable: ${{ env.SOLUTION_FILE }}"
              FIRST_SOLUTION=$(find . -name "*.sln" -maxdepth 2 | head -1)
              echo "‚úÖ Utilisation de la premi√®re solution trouv√©e: $FIRST_SOLUTION"
              echo "DETECTED_SOLUTION=$FIRST_SOLUTION" >> $GITHUB_ENV
            fi
          else
            echo "‚ùå Aucune solution trouv√©e, recherche du projet principal..."
            # Chercher le projet principal (probablement ReRe.csproj)
            MAIN_PROJECT=$(find . -name "ReRe.csproj" -o -name "*.csproj" | grep -v Test | head -1)
            if [ -n "$MAIN_PROJECT" ]; then
              echo "‚úÖ Projet principal trouv√©: $MAIN_PROJECT"
              echo "DETECTED_SOLUTION=$MAIN_PROJECT" >> $GITHUB_ENV
            else
              echo "‚ùå Aucun projet trouv√©"
              exit 1
            fi
          fi
          
          echo "üéØ Solution/Projet √† utiliser: $DETECTED_SOLUTION"

      - name: üì¶ Cache NuGet Packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: üì¶ Restore Dependencies
        run: |
          echo "üì¶ Restoring NuGet packages for: ${{ env.DETECTED_SOLUTION }}"
          dotnet restore "${{ env.DETECTED_SOLUTION }}" --verbosity minimal

      - name: üîß Build Application
        run: |
          echo "üîß Building ReRe application..."
          dotnet build "${{ env.DETECTED_SOLUTION }}" \
            --configuration ${{ env.BUILD_CONFIGURATION }} \
            --no-restore \
            --verbosity minimal

      - name: üîç Verify Test Project
        run: |
          echo "üîç Verifying test project exists..."
          
          # Chercher tous les projets de test possibles
          echo "üîç Recherche des projets de test..."
          TEST_PROJECTS=$(find . -name "*Test*.csproj" -o -name "*Tests*.csproj")
          
          if [ -n "$TEST_PROJECTS" ]; then
            echo "‚úÖ Projets de test trouv√©s:"
            echo "$TEST_PROJECTS"
            
            # Utiliser le premier projet de test trouv√©
            FIRST_TEST_PROJECT=$(echo "$TEST_PROJECTS" | head -1)
            echo "‚úÖ Utilisation du projet de test: $FIRST_TEST_PROJECT"
            echo "DETECTED_TEST_PROJECT=$FIRST_TEST_PROJECT" >> $GITHUB_ENV
          else
            echo "‚ùå Aucun projet de test trouv√©"
            echo "üîç Structure des dossiers:"
            find . -type d -name "*Test*" -o -name "*Tests*"
            exit 1
          fi

      - name: üß™ Run Unit Tests
        run: |
          echo "üß™ Running Unit Tests..."
          TEST_PROJECT_TO_USE="${{ env.DETECTED_TEST_PROJECT }}"
          echo "üìÅ Using test project: $TEST_PROJECT_TO_USE"
          
          # Cr√©er le dossier TestResults s'il n'existe pas
          mkdir -p ./TestResults
          
          dotnet test "$TEST_PROJECT_TO_USE" \
            --configuration ${{ env.BUILD_CONFIGURATION }} \
            --no-build \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./TestResults \
            --filter "Category!=Integration&Category!=IntegrationTest" \
            --logger "trx;LogFileName=unit-test-results.trx" \
            --logger "console;verbosity=detailed" || echo "‚ö†Ô∏è Unit tests completed with issues"
          
          echo "‚úÖ Unit tests step completed"

      - name: üîó Run Integration Tests
        run: |
          echo "üîó Running Integration Tests..."
          TEST_PROJECT_TO_USE="${{ env.DETECTED_TEST_PROJECT }}"
          echo "üìÅ Using test project: $TEST_PROJECT_TO_USE"
          
          dotnet test "$TEST_PROJECT_TO_USE" \
            --configuration ${{ env.BUILD_CONFIGURATION }} \
            --no-build \
            --verbosity normal \
            --results-directory ./TestResults \
            --filter "Category=Integration|Category=IntegrationTest|FullyQualifiedName~IntegrationTest" \
            --logger "trx;LogFileName=integration-test-results.trx" \
            --logger "console;verbosity=detailed" || echo "‚ö†Ô∏è Integration tests completed with issues"
          
          echo "‚úÖ Integration tests step completed"

      - name: üìä Generate Coverage Report
        if: always()
        run: |
          echo "üìä Generating coverage report..."
          dotnet tool install -g dotnet-reportgenerator-globaltool
          
          # V√©rifier si des fichiers de couverture existent
          echo "üîç Looking for coverage files..."
          find ./TestResults -name "*.xml" -type f || echo "No XML files found"
          find ./TestResults -name "*coverage*" -type f || echo "No coverage files found"
          
          if ls ./TestResults/**/coverage.cobertura.xml 1> /dev/null 2>&1; then
            echo "‚úÖ Coverage files found, generating report..."
            reportgenerator \
              -reports:"./TestResults/**/coverage.cobertura.xml" \
              -targetdir:"./TestResults/CoverageReport" \
              -reporttypes:"Html;Cobertura;JsonSummary" \
              -verbosity:Info
            echo "‚úÖ Coverage report generated"
          else
            echo "‚ö†Ô∏è No coverage files found, skipping report generation"
            echo "üìÅ TestResults directory contents:"
            ls -la ./TestResults/ || echo "TestResults directory not found"
          fi

      - name: üì§ Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ReRe-test-results-${{ github.run_number }}
          path: |
            ./TestResults/**/*.trx
            ./TestResults/**/TestResults.xml
          retention-days: 7

      - name: üì§ Upload Coverage Report
        uses: actions/upload-artifact@v4
        if: always() && hashFiles('./TestResults/CoverageReport/**/*') != ''
        with:
          name: ReRe-coverage-report-${{ github.run_number }}
          path: ./TestResults/CoverageReport/
          retention-days: 7

      - name: üìã Parse Test Results
        if: always()
        run: |
          echo "üìã Parsing test results..."
          
          # Fonction pour extraire les r√©sultats de test
          extract_test_results() {
            local file=$1
            local prefix=$2
            
            echo "üîç Looking for test results in: $file"
            if [ -f "$file" ]; then
              echo "‚úÖ Found test results file: $file"
              PASSED=$(grep -o 'passed="[0-9]*"' "$file" | grep -o '[0-9]*' || echo "0")
              FAILED=$(grep -o 'failed="[0-9]*"' "$file" | grep -o '[0-9]*' || echo "0")
              SKIPPED=$(grep -o 'skipped="[0-9]*"' "$file" | grep -o '[0-9]*' || echo "0")
              
              echo "üìä $prefix Results: Passed=$PASSED, Failed=$FAILED, Skipped=$SKIPPED"
            else
              echo "‚ö†Ô∏è Test result file not found: $file"
              PASSED=0
              FAILED=0
              SKIPPED=0
            fi
            
            echo "${prefix}_PASSED=$PASSED" >> $GITHUB_ENV
            echo "${prefix}_FAILED=$FAILED" >> $GITHUB_ENV
            echo "${prefix}_SKIPPED=$SKIPPED" >> $GITHUB_ENV
          }
          
          # Lister tous les fichiers dans TestResults
          echo "üìÅ TestResults directory contents:"
          find ./TestResults -type f || echo "No files in TestResults"
          
          extract_test_results "./TestResults/unit-test-results.trx" "UNIT_TESTS"
          extract_test_results "./TestResults/integration-test-results.trx" "INTEGRATION_TESTS"

      - name: üìä Test Summary
        if: always()
        run: |
          echo "## üß™ ReRe Test Suite Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìà Test Statistics" >> $GITHUB_STEP_SUMMARY
          echo "| Test Type | ‚úÖ Passed | ‚ùå Failed | ‚è≠Ô∏è Skipped | Total |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-----------|-----------|------------|-------|" >> $GITHUB_STEP_SUMMARY
          
          UNIT_TOTAL=$((${{ env.UNIT_TESTS_PASSED || 0 }} + ${{ env.UNIT_TESTS_FAILED || 0 }} + ${{ env.UNIT_TESTS_SKIPPED || 0 }}))
          INTEGRATION_TOTAL=$((${{ env.INTEGRATION_TESTS_PASSED || 0 }} + ${{ env.INTEGRATION_TESTS_FAILED || 0 }} + ${{ env.INTEGRATION_TESTS_SKIPPED || 0 }}))
          
          echo "| **Unit Tests** | ${{ env.UNIT_TESTS_PASSED || 0 }} | ${{ env.UNIT_TESTS_FAILED || 0 }} | ${{ env.UNIT_TESTS_SKIPPED || 0 }} | $UNIT_TOTAL |" >> $GITHUB_STEP_SUMMARY
          echo "| **Integration Tests** | ${{ env.INTEGRATION_TESTS_PASSED || 0 }} | ${{ env.INTEGRATION_TESTS_FAILED || 0 }} | ${{ env.INTEGRATION_TESTS_SKIPPED || 0 }} | $INTEGRATION_TOTAL |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üéØ Test Coverage" >> $GITHUB_STEP_SUMMARY
          echo "- üìä Detailed coverage report available in artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- üìã Test results available in TRX format" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üèóÔ∏è Build Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Project**: ReRe" >> $GITHUB_STEP_SUMMARY
          echo "- **Solution**: ${{ env.DETECTED_SOLUTION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Test Project**: ${{ env.DETECTED_TEST_PROJECT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Framework**: .NET ${{ env.DOTNET_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Configuration**: ${{ env.BUILD_CONFIGURATION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: Ubuntu Latest" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Time**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

      - name: üìÅ Display Project Structure
        if: always()
        run: |
          echo "üìÅ ReRe Test Project Structure:"
          echo ""
          echo "üß™ Unit Tests:"
          find . -name "*Test*.cs" -not -path "*/Integration/*" -not -name "*IntegrationTest*" | head -10 || echo "No unit test files found"
          echo ""
          echo "üîó Integration Tests:"
          find . -name "*IntegrationTest*.cs" -o -path "*/Integration/*" -name "*.cs" | head -10 || echo "No integration test files found"
          echo ""
          echo "üìä Test Statistics:"
          UNIT_TEST_FILES=$(find . -name "*Test*.cs" -not -path "*/Integration/*" -not -name "*IntegrationTest*" | wc -l)
          INTEGRATION_TEST_FILES=$(find . -name "*IntegrationTest*.cs" -o -path "*/Integration/*" -name "*.cs" | wc -l)
          TOTAL_TEST_FILES=$((UNIT_TEST_FILES + INTEGRATION_TEST_FILES))
          
          echo "  - Unit test files: $UNIT_TEST_FILES"
          echo "  - Integration test files: $INTEGRATION_TEST_FILES"
          echo "  - Total test files: $TOTAL_TEST_FILES"

      - name: ‚ùå Fail on Test Failures
        if: always()
        run: |
          TOTAL_FAILED=$((${{ env.UNIT_TESTS_FAILED || 0 }} + ${{ env.INTEGRATION_TESTS_FAILED || 0 }}))
          if [ $TOTAL_FAILED -gt 0 ]; then
            echo "‚ùå Tests failed! Total failures: $TOTAL_FAILED"
            exit 1
          else
            echo "‚úÖ All tests passed successfully!"
          fi
